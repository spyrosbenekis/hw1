Στο πρόγραμμα υλοποιούνται δύο συναρτήσεις:

1.  bool square(int64_t num)
    
    Η συνάρτηση square δέχεται σαν όρισμα τον αριθμό num, για τον οποίο υπολογίζω την ρίζα του sqr -με χρήση της αντίστοιχης συνάρτησης. Στο τέλος επιστρέφει αν τα αποτελέσματα των δύο συνθηκών, δηλαδή αν ο αριθμός είναι τετράγωνο ενός πρώτου αριθμού. Έτσι πρώτα ελέγχεται αν είναι ίσος με το τετράγωνο της ρίζας του και αν η ρίζα του είναι πρώτος αριθμός.

2.  bool prime(int64_t num)

    Η συνάρτηση prime δέχεται σαν όρισμα τον αριθμό num και ελέγχει αν είναι πρώτος. Αν ο αριθμός είναι 1, επιστρέφει false γιατί το 1 δεν θεωρείται πρώτος αριθμός.
    Αν ο αριθμός είναι 2, τότε επιστρέφει true, καθώς το 2 είναι ο μόνος άρτιος πρώτος αριθμός.
    Αν ο αριθμός είναι άρτιος (διαιρείται με το 2), επιστρέφει false γιατί δεν μπορεί να είναι πρώτος, εκτός αν είναι το 2 (όπως προαναφέρθηκε).. Επίσης, ελέγχει αν ο αριθμός είναι άρτιος (οι οποίοι διαιρούνται σίγουρα με το 2) που δεν είναι πρώτοι.
    Έτσι αν καμία συνθήκη δεν ισχύει, τότε ελέγχεται αν ο αριθμος διαιρείται με κάποιον περιττό -δεν είναι άρτιος οπότε είναι περιττό να ελέγξουμε και τους άρτιους. Αυτό γίνεται με τον βρόχο, που ξεκινάει από το 3 (τον πρώτο περριτό) και εκτελείται μέχρι την ρίζα του αριθμού, για να περιορίσουμε το πλήθος των επαναλήψεων. Αυτή η προσέγγιση ισχύει, διότι όλοι οι αριθμοί -εκτός των πρώτων- είναι γινόμενο δύο άλλων αριθμών έστω n = α * β. Το α ή το β δεν γίνεται να είναι μεγαλύτερο από την ρίζα, εφόσον το γινόμενο τους θα είναι μεγαλύτερο από το n, αφού n = ρίζα * ρίζα. Όπότε σε κάθε γινόμενο του n ένας από τους δύο αριθμούς θα είναι μικρότερος από την ρίζα, αν δεν ισχύει αυτό τότε ο αριθμός θα είναι πρώτος.

Και οι δύο είναι τύπου boolean, εφόσον το μόνο που κάνουν είναι να επιστρέψουν τα αποτελέσματα κάποιον συνθηκών.

Στην main αρχικά ελέγχω την εγκυρότητα των δεδομένων εισόδου, αν δεν είναι έγκυρες οι τιμές τότε επιστρέφει την τιμή 1. Στη συνέχεια, ο βρόγχος ξεκινάει και τερματίζει στις ρίζες των st και fn αντίστοιχα, καθώς αν σκεφτούμε με αντίστροφη λογική το πρόβλημα θα καταλάβουμε πως αυτό που χρειάζεται είναι να βρούμε τους αριθμούς που είναι πρώτοι, έχουν τέλειο τετράγωνο (το num), το κάτοπτρό του τετραγώνου τους (kat) είναι επίσης τέλειο τετράγωνο ενός πρώτου αριθμού και το num να μην είναι παλινδρομικό. Έτσι περιορίζουμε το πλήθος των επαναλήψεων καθώς υπολογίζουμε σε ένα συγκεκριμένο και στοχευμένο εύρος αριθμών, που στην πλειονότητα τους οι συνθήκες ισχύουν, αντί να πάμε σε ένα μεγάλο εύρος. Έτσι, αφού υπολογιστεί το τετράγωνο στην num, υπολογίζεται το κάτοπρο στον βρόχο do-while. Στην πρώτη εκτέλεση, η εντολή (kat * 10) δεν έχει σημασία (αφού το kat αρχικοποιήθηκε με 0), ενώ γενικά για κάθε επανάληψη, το ψηφίο του num που βρίσκεται στις μονάδες προστίθεται στο kat, το οποίο αρχικά είναι μηδέν, πολλαπλασιασμένο με 10 και μετά προστίθεται το υπόλοιπο του num που προέκυψε από τη διαιρέση με το 10. Αυτή η διαδικασία συνεχίζεται μέχρι το num να γίνει μηδέν, στο οποίο σημείο έχει ολοκληρωθεί ο υπολογισμός του αντίστροφου του αρχικού αριθμού, ενώ σε κάθε επανάληψη, η τιμή του num διαιρείται με το 10. Στην συνέχεια, ελέγχω τις τρεις συνθήκες που ικανοποιούνται για να είναι ένας φυσικός αριθμός ένα κατοπτρικό πρώτο τετράγωνο, δηλαδή ο αριθμός να είναι διαφορετικός από το κάτοπτρο του (να μην είναι παλινδρομικός), το κάτοπτρο να είναι τέλειο τετράγωνο ενός πρώτου αριθμού και ο αριθμός είναι τέλειο τετράγωνο ενός πρώτου αριθμού (που ελέγχεται στην τρίτη συνθήκη, ενώ το να είναι τέλειο τετράγωνο δεν χρειάζεται να ελεγχθείν εφόσον το num=i*i).